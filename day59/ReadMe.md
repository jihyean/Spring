## 오전 9:24 2023-08-01

보드DAO에서 하는거 다 유틸에서 함
실제로 어떠한 행동을 하는 건 객체인 경우가 많음
사실 모든 행동을 리모콘으로 하는 것처럼
main 액션을 하는 진짜 주체는 ---> 보드DAO(selectAll selectOne)

# 의존관계가 생겼으니 의존 주입 필요

1. 의존 관계 발생
2. 의존 주입(DI)
	1) 생성자 주입
	2) setter 주입

3. 설정(.xml)
	: POJO -> 스프링 컨테이너한테 설정을 해야하므로 appliactionContext.xml
	만약에 not POJO(서블릿)이었다면 서블릿 컨테이너(톰캣)한테 설정을 해야하므로 web.xml


client
1. 스프링 컨테이너 구동
	: 팩토리 패턴을 사용하고 있어서, 객체명을 LookUp하여 객체반환이 가능!

xml에서 lgTV랑 samsungTV 둘 다 같은 id로 지정후
필요할때마다 둘중하나를 가르는 방식으로 하기도 함
---> xml의 변경만으로도 아웃풋이 달라짐

하지만 보통 객체의 이름은 같게 짓지는 않는다
---> 액션류는 바뀌는 일이 적고 조금씩 구동방식이 다를 수 있기 때문
---> 보통은 모듈마다 같게 함(업그레이드 등등 주로 광고/멤버변수 변경 등등)
	=> 옛날꺼 가려놓는구나


setter 방식은 생성자 주입 방식과 형태는 비슷하지만
이름으로 찾아가기 때문에 "이름"을 반드시 일치시켜야 한다

<bean class="test.IPhone" id="apple">
해당코드만 작성시에는 consturutor가 아니기 때문에 기본생성자임

[순서]
지연로딩은 호출 시점에 생성됨 
따라서 현재 호출되지 않았음
IPhone 기본 생성자 호출
setter 호출 시도
setter를 하려면 watch가 필요 ---> 갤럭시워치
갤럭시 워치 기본 생성자 호출
setter 호출 마무리

LG TV 생성자 호출 -> setter 주입으로 변경

new는 객체화
스프링 컨테이너에게 객체 생성 및 관리를 부탁하는 방법

new 하는 법 2가지
1) .xml <bean>
	xml의 단점
	객체를 생성하는 양에 비해 코드량이 지나치게 많아짐
	: 설정 과다
	: 가독성이 떨어짐
	: 구조 파악(JAVA)이 어려움(자바 구조 예상하기 어려움)
	
2) @
	설정을 .java에 할 수는 없을까?
	JAVA의 구조파악에 도움
	.xml(설정)이 줄어듦 -> 가독성 향상


네임스페이스
context 네임스페이스를 추가해야 @을 사용할 수 있음

<context:component-scan base-package="test"></context:component-scan>
context라는 네임스페이스에서
conponent-scan이라는 기능의 엘리먼트(태그)를 꺼내어 사용
"test"라는 이름의 패키지를 스캔해줘!~~

이때 component == Bean == 모듈 == 위젯


다음의 세가지 문법 모두 같은 뜻
GalaxyPhone gp = new GalaxyPhone();
<bean class="test.GalaxyPhone" id="gp" />
@Component("gp")

setter 인젝션과 같지만 내부 로직이 조금은 다르다
근데 거의 같음

@Autowired
나에게 해당하는 자료형이 메모리에 있다면,
나에게 DI(의존성주입) 해줘!~~

즉, 메모리에 있어야 한다
--> new 해야한다!!!


[순서]
@Component
-> 널포인트 예외
	: 의존관계를 가진 watch가 DI되지 않았기 때문에 오류발생

@Autowired
-> 빈 생성 예외
	: 메모리에 watch와 "같은 자료형"을 가진 객체가 없어서 오류발생

메모리에 watch와 같은 자료형을 가진 객체를 생성하면?
1) <bean>으로 생성
	=> 잘됨
2) 메모리에 watch와 같은 자료형을 가진 객체가 2개 이상이면?
	=> bean 생성 예외 발생함
		: 자료형을 보고 스프링 컨테이너가 작업처리를 하기 때문에

하나의 컴포넌트에 여러번의 변경이 되는 경우에는
xml로 관리

※ 그러므로 어노테이션과 xml 방식 모두 혼합하여 사용할 수 있어야 함


삼성tv A리모콘 @
엘지tv B리모콘 .xml

